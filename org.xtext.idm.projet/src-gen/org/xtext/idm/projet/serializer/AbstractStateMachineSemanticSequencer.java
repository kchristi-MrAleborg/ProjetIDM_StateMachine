/*
 * generated by Xtext
 */
package org.xtext.idm.projet.serializer;

import SimplStateMachine.Assignment;
import SimplStateMachine.BooleanData;
import SimplStateMachine.BooleanVariable;
import SimplStateMachine.CompositeState;
import SimplStateMachine.Event;
import SimplStateMachine.InitialState;
import SimplStateMachine.IntegerData;
import SimplStateMachine.IntegerVariable;
import SimplStateMachine.Operation;
import SimplStateMachine.SimplStateMachinePackage;
import SimplStateMachine.State;
import SimplStateMachine.StateMachine;
import SimplStateMachine.Transition;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.idm.projet.services.StateMachineGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractStateMachineSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private StateMachineGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == SimplStateMachinePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case SimplStateMachinePackage.ASSIGNMENT:
				if(context == grammarAccess.getAssignmentRule()) {
					sequence_Assignment_BooleanAssignment_IntegerAssignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getBooleanAssignmentRule()) {
					sequence_BooleanAssignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getIntegerAssignmentRule()) {
					sequence_IntegerAssignment(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case SimplStateMachinePackage.BOOLEAN_DATA:
				sequence_booleanData(context, (BooleanData) semanticObject); 
				return; 
			case SimplStateMachinePackage.BOOLEAN_VARIABLE:
				sequence_booleanVariable(context, (BooleanVariable) semanticObject); 
				return; 
			case SimplStateMachinePackage.COMPOSITE_STATE:
				sequence_CompositeState(context, (CompositeState) semanticObject); 
				return; 
			case SimplStateMachinePackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case SimplStateMachinePackage.INITIAL_STATE:
				sequence_InitialState(context, (InitialState) semanticObject); 
				return; 
			case SimplStateMachinePackage.INTEGER_DATA:
				sequence_integerData(context, (IntegerData) semanticObject); 
				return; 
			case SimplStateMachinePackage.INTEGER_VARIABLE:
				sequence_integerVariable(context, (IntegerVariable) semanticObject); 
				return; 
			case SimplStateMachinePackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case SimplStateMachinePackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case SimplStateMachinePackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case SimplStateMachinePackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((_name=STRING? variable=[BooleanVariable|ID] expression=booleanData) | (_name=STRING? variable=[IntegerVariable|ID] expression=integerData))
	 */
	protected void sequence_Assignment_BooleanAssignment_IntegerAssignment(EObject context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (_name=STRING? variable=[BooleanVariable|ID] expression=booleanData)
	 */
	protected void sequence_BooleanAssignment(EObject context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID states+=State states+=State* initialState=InitialState)
	 */
	protected void sequence_CompositeState(EObject context, CompositeState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.EVENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     referencedState=[State|ID]
	 */
	protected void sequence_InitialState(EObject context, InitialState semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.INITIAL_STATE__REFERENCED_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.INITIAL_STATE__REFERENCED_STATE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInitialStateAccess().getReferencedStateStateIDTerminalRuleCall_3_0_1(), semanticObject.getReferencedState());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (_name=STRING? variable=[IntegerVariable|ID] expression=integerData)
	 */
	protected void sequence_IntegerAssignment(EObject context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (contents+=Assignment contents+=Assignment*)
	 */
	protected void sequence_Operation(EObject context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         variables+=Variable* 
	 *         events+=Event 
	 *         events+=Event* 
	 *         states+=oneState 
	 *         states+=oneState* 
	 *         initialState=InitialState 
	 *         transitions+=Transition 
	 *         transitions+=Transition*
	 *     )
	 */
	protected void sequence_StateMachine(EObject context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID operation=Operation?)
	 */
	protected void sequence_State(EObject context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (source=[State|ID] target=[State|ID] event=[Event|STRING])
	 */
	protected void sequence_Transition(EObject context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=Bool
	 */
	protected void sequence_booleanData(EObject context, BooleanData semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.BOOLEAN_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.BOOLEAN_DATA__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanDataAccess().getValueBoolParserRuleCall_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=booleanData?)
	 */
	protected void sequence_booleanVariable(EObject context, BooleanVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_integerData(EObject context, IntegerData semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.INTEGER_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.INTEGER_DATA__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerDataAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=integerData?)
	 */
	protected void sequence_integerVariable(EObject context, IntegerVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
